#include <bits/stdc++.h>
using namespace std;
#define lli long long int
#define f first
#define s second
#define pb push_back
#define MAXN 2000005
#define INF 10000000000000005
#define mod 1000000007
#define loop(i,a,b) for  (lli i=(a); i<= (signed)(b); i++)
#define lp(i,a) for(lli i = 0;i<(signed)(a); i++)
#define rev(a) reverse(a.begin(), a.end())
#define prlli(a) cout<<a<<" "
#define prllil(a) cout<<a<<endl;
#define debug cout<<"I am here"<<endl;
typedef vector<lli> vi;
/*
   Observation:Question asks to split so that the ratio of d and K is the same. 
   Suppose you have optimal spliting for length i. Then for next, it must also have the same ratio because that is the only way to add onto that segment. 
   i.e KDDD is 1. For the next value, it must also have a 1:3 ratio of K  and d because otherwise it would use a segment of different length
   another way of looking at it, plot it on a graph. See that all the maximums make a slope towards the origin. 
   So, for each k and d, treat as x and y. find slope. The answer is just oldslope + 1 because the new appended region has the same ratio (which is convienently slope)
   in my code, i use gcd to find the scale, and divide both by the GCD to get the ratio. Then stored into a map with current largest.
 
*/
 
int main()
{
  //freopen("inp.txt","r", stdin);
  lli t;
  cin>>t;
  lp(_,t){
    lli n;
    cin>>n;
    string s;
    cin>>s;
    lli k = 0, d=  0;
    map<pair<lli,lli>,lli> dp;
    dp[{0, 0}]=  0 ;
    lp(i,n){
        if(s[i] == 'D'){
            d++;
        }
        else if(s[i] == 'K'){
            k++;
        }
        lli scale = __gcd(k, d);
        lli dk = k/ scale;
        lli dd = d / scale;
        dp[{dk, dd}]++;
        cout<<dp[{dk, dd}]<<" " ;
    }
    cout<<endl;;
  }
}
